# MCP XGBoost Server - Kubernetes Deployment Values
# This values file is designed to work with the community-tooling generic chart

# Application configuration
nameOverride: "mcp-xgboost"
fullnameOverride: "mcp-xgboost"

# Image configuration
image:
  repository: "mcp-xgboost"
  tag: "latest"
  pullPolicy: IfNotPresent

# Replica configuration
replicaCount: 1

# Service configuration
service:
  type: ClusterIP
  ports:
    - targetPort: http
      protocol: TCP
      name: http
      port: 8000

# Container port configuration
containerPort: 8000
ports:
  - containerPort: 8000
    name: "http"
    protocol: "TCP"

# Environment variables
env:
  MCP_HOST: "0.0.0.0"
  MCP_PORT: "8000"
  PYTHONPATH: "/app"
  # Storage backend configuration
  MCP_STORAGE_BACKEND: "redis"  # Use Redis for distributed storage
  # Redis configuration
  MCP_REDIS_HOST: "redis-service"
  MCP_REDIS_PORT: "6379"
  MCP_REDIS_DATABASE: "0"
  MCP_REDIS_MAX_CONNECTIONS: "10"
  MCP_REDIS_SOCKET_TIMEOUT: "5"
  MCP_REDIS_SOCKET_CONNECT_TIMEOUT: "5"
  MCP_REDIS_RETRY_ON_TIMEOUT: "true"
  MCP_REDIS_HEALTH_CHECK_INTERVAL: "30"

# Redis configuration
redis:
  enabled: true
  host: "redis-service"
  port: 6379
  password: ""
  database: 0
  # Redis deployment configuration
  deploy:
    enabled: true
    image: "redis:7-alpine"
    resources:
      limits:
        cpu: 200m
        memory: 256Mi
      requests:
        cpu: 100m
        memory: 128Mi

# Resource configuration
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 256Mi

# Probes configuration
livenessProbe:
  httpGet:
    path: /health
    port: 8000
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /health
    port: 8000
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

# Security context
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: false

# Pod security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000

# Ingress configuration (disabled by default)
ingress:
  enabled: false
  className: ""
  annotations: {}
  hosts:
    - host: mcp-xgboost.local
      paths:
        - path: /
          pathType: Prefix
  tls: []

# Service account
serviceAccount:
  create: true
  annotations: {}
  name: ""

# Pod annotations
podAnnotations:
  # Istio sidecar injection will be enabled at namespace level
  # sidecar.istio.io/inject: "true"

# Pod labels
podLabels:
  # Istio service mesh labels
  app: mcp-xgboost
  version: v1

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}

# Autoscaling (enabled for distributed deployment)
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  # Additional scaling metrics
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 100
        periodSeconds: 60
      - type: Pods
        value: 2
        periodSeconds: 60

# Persistent volume (disabled in favor of Redis)
persistence:
  enabled: false
  storageClass: ""
  accessMode: ReadWriteOnce
  size: 8Gi

# Network policy (disabled by default)
networkPolicy:
  enabled: false

# Pod disruption budget (enabled for high availability)
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Monitoring
metrics:
  enabled: false
  serviceMonitor:
    enabled: false
    interval: 30s
    scrapeTimeout: 10s

# Additional resources - Istio Service Mesh Configuration and Redis
additionalResources:
  # Redis Service for model storage
  - apiVersion: v1
    kind: Service
    metadata:
      name: redis-service
      namespace: "{{ .Release.Namespace }}"
      labels:
        app: redis
        component: storage
    spec:
      selector:
        app: redis
      ports:
      - port: 6379
        targetPort: 6379
        protocol: TCP
        name: redis
      type: ClusterIP

  # Redis Deployment for model storage
  - apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: redis-deployment
      namespace: "{{ .Release.Namespace }}"
      labels:
        app: redis
        component: storage
    spec:
      replicas: 1
      selector:
        matchLabels:
          app: redis
      template:
        metadata:
          labels:
            app: redis
            component: storage
        spec:
          containers:
          - name: redis
            image: "{{ .Values.redis.deploy.image }}"
            ports:
            - containerPort: 6379
              name: redis
            resources:
              limits:
                cpu: "{{ .Values.redis.deploy.resources.limits.cpu }}"
                memory: "{{ .Values.redis.deploy.resources.limits.memory }}"
              requests:
                cpu: "{{ .Values.redis.deploy.resources.requests.cpu }}"
                memory: "{{ .Values.redis.deploy.resources.requests.memory }}"
            livenessProbe:
              tcpSocket:
                port: 6379
              initialDelaySeconds: 30
              periodSeconds: 10
            readinessProbe:
              tcpSocket:
                port: 6379
              initialDelaySeconds: 5
              periodSeconds: 5
            securityContext:
              runAsNonRoot: true
              runAsUser: 999
              allowPrivilegeEscalation: false
              capabilities:
                drop:
                  - ALL
              readOnlyRootFilesystem: false

  # Istio Gateway for external traffic
  - apiVersion: networking.istio.io/v1beta1
    kind: Gateway
    metadata:
      name: "{{ include \"generic-chart.fullname\" . }}-gateway"
      namespace: "{{ .Release.Namespace }}"
      labels:
        app.kubernetes.io/name: "{{ include \"generic-chart.name\" . }}"
        app.kubernetes.io/instance: "{{ .Release.Name }}"
        app.kubernetes.io/component: gateway
    spec:
      selector:
        istio: ingressgateway # use Istio default controller
      servers:
      - port:
          number: 80
          name: http
          protocol: HTTP
        hosts:
        - "*"
      - port:
          number: 443
          name: https
          protocol: HTTPS
        tls:
          mode: SIMPLE
          credentialName: "{{ include \"generic-chart.fullname\" . }}-tls"
        hosts:
        - "*"

  # Istio VirtualService for traffic routing
  - apiVersion: networking.istio.io/v1beta1
    kind: VirtualService
    metadata:
      name: "{{ include \"generic-chart.fullname\" . }}-vs"
      namespace: "{{ .Release.Namespace }}"
      labels:
        app.kubernetes.io/name: "{{ include \"generic-chart.name\" . }}"
        app.kubernetes.io/instance: "{{ .Release.Name }}"
        app.kubernetes.io/component: virtualservice
    spec:
      hosts:
      - "*"
      gateways:
      - "{{ include \"generic-chart.fullname\" . }}-gateway"
      http:
      - match:
        - uri:
            prefix: /health
        route:
        - destination:
            host: "{{ include \"generic-chart.fullname\" . }}.{{ .Release.Namespace }}.svc.cluster.local"
            port:
              number: "{{ .Values.service.ports.0.port }}"
        timeout: 30s
        retries:
          attempts: 3
          perTryTimeout: 10s
      - match:
        - uri:
            prefix: /
        route:
        - destination:
            host: "{{ include \"generic-chart.fullname\" . }}.{{ .Release.Namespace }}.svc.cluster.local"
            port:
              number: "{{ .Values.service.ports.0.port }}"
        timeout: 30s
        retries:
          attempts: 3
          perTryTimeout: 10s

  # Istio DestinationRule for load balancing and circuit breaking
  - apiVersion: networking.istio.io/v1beta1
    kind: DestinationRule
    metadata:
      name: "{{ include \"generic-chart.fullname\" . }}-dr"
      namespace: "{{ .Release.Namespace }}"
      labels:
        app.kubernetes.io/name: "{{ include \"generic-chart.name\" . }}"
        app.kubernetes.io/instance: "{{ .Release.Name }}"
        app.kubernetes.io/component: destinationrule
    spec:
      host: "{{ include \"generic-chart.fullname\" . }}.{{ .Release.Namespace }}.svc.cluster.local"
      trafficPolicy:
        connectionPool:
          tcp:
            maxConnections: 10
          http:
            http1MaxPendingRequests: 10
            maxRequestsPerConnection: 2
        outlierDetection:
          consecutiveErrors: 3
          interval: 30s
          baseEjectionTime: 30s
          maxEjectionPercent: 50
        loadBalancer:
          simple: LEAST_CONN
      subsets:
      - name: v1
        labels:
          version: v1

  # Istio PeerAuthentication for mTLS
  - apiVersion: security.istio.io/v1beta1
    kind: PeerAuthentication
    metadata:
      name: "{{ include \"generic-chart.fullname\" . }}-peerauth"
      namespace: "{{ .Release.Namespace }}"
      labels:
        app.kubernetes.io/name: "{{ include \"generic-chart.name\" . }}"
        app.kubernetes.io/instance: "{{ .Release.Name }}"
        app.kubernetes.io/component: peerauthentication
    spec:
      selector:
        matchLabels:
          app: "{{ include \"generic-chart.name\" . }}"
      mtls:
        mode: STRICT

  # Istio AuthorizationPolicy for access control
  - apiVersion: security.istio.io/v1beta1
    kind: AuthorizationPolicy
    metadata:
      name: "{{ include \"generic-chart.fullname\" . }}-authz"
      namespace: "{{ .Release.Namespace }}"
      labels:
        app.kubernetes.io/name: "{{ include \"generic-chart.name\" . }}"
        app.kubernetes.io/instance: "{{ .Release.Name }}"
        app.kubernetes.io/component: authorizationpolicy
    spec:
      selector:
        matchLabels:
          app: "{{ include \"generic-chart.name\" . }}"
      rules:
      - from:
        - source:
            principals: ["cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account"]
      - to:
        - operation:
            methods: ["GET", "POST"]
            paths: ["/health", "/"] 